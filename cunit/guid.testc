#include "cunit/cunit.h"
#include "imap/message_guid.h"

static void test_guid(void)
{
    static const char TEXT[] = "lorem ipsum dolor sit amet, "
                               "consectetur adipisicing elit\n";
    static const unsigned char SHA1[20] = {
        0xd1,0xb0,0x52,0xa0,0x12,0xcb,0xec,0xd5,0x42,0x5b,
        0x23,0xf3,0x61,0x42,0x6f,0x24,0xdb,0x56,0xd7,0x45
    };
    struct message_guid guid;
    struct message_guid guid2;
    int r;

    message_guid_set_null(&guid);
    r = message_guid_isnull(&guid);
    CU_ASSERT_EQUAL(r, 1);
    r = message_guid_isnull(&guid);
    CU_ASSERT_EQUAL(r, 1);

    message_guid_generate(&guid, TEXT, sizeof(TEXT)-1);
    r = message_guid_isnull(&guid);
    CU_ASSERT_EQUAL(r, 0);
    r = message_guid_isnull(&guid);
    CU_ASSERT_EQUAL(r, 0);
    CU_ASSERT_EQUAL(memcmp(&guid.value, SHA1, sizeof(SHA1)), 0);

    memset(&guid2, 0x45, sizeof(guid2));
    r = message_guid_equal(&guid, &guid2);
    CU_ASSERT_EQUAL(r, 0);

    message_guid_copy(&guid2, &guid);
    CU_ASSERT_EQUAL(memcmp(&guid2.value, SHA1, sizeof(SHA1)), 0);
    r = message_guid_equal(&guid, &guid2);
    CU_ASSERT_EQUAL(r, 1);
}

static void test_import(void)
{
    static const unsigned char SHA1[20] = {
        0xd1,0xb0,0x52,0xa0,0x12,0xcb,0xec,0xd5,0x42,0x5b,
        0x23,0xf3,0x61,0x42,0x6f,0x24,0xdb,0x56,0xd7,0x45
    };
    struct message_guid guid;
    unsigned char buf[MESSAGE_GUID_SIZE];
    int r;

    memset(&guid, 0x45, sizeof(guid));
    message_guid_import(&guid, SHA1);
    r = message_guid_isnull(&guid);
    CU_ASSERT_EQUAL(r, 0);
    CU_ASSERT_EQUAL(memcmp(&guid.value, SHA1, sizeof(SHA1)), 0);

    memset(buf, 0x69, sizeof(buf));
    message_guid_export(&guid, buf);
    CU_ASSERT_EQUAL(memcmp(buf, SHA1, sizeof(SHA1)), 0);
}

static void test_encode(void)
{
    static const char SHA1HEX[41] = "d1b052a012cbecd5425b23f361426f24db56d745";
    static const unsigned char SHA1BIN[20] = {
        0xd1,0xb0,0x52,0xa0,0x12,0xcb,0xec,0xd5,0x42,0x5b,
        0x23,0xf3,0x61,0x42,0x6f,0x24,0xdb,0x56,0xd7,0x45
    };
    struct message_guid guid;
    const char *s;
    int r;

    memset(&guid, 0x45, sizeof(guid));
    message_guid_decode(&guid, SHA1HEX);
    r = message_guid_isnull(&guid);
    CU_ASSERT_EQUAL(r, 0);
    CU_ASSERT_EQUAL(memcmp(&guid.value, SHA1BIN, sizeof(SHA1BIN)), 0);

    s = message_guid_encode(&guid);
    CU_ASSERT_STRING_EQUAL(s, SHA1HEX);
}

static void test_null(void)
{
    static const unsigned char SHA1BIN[20] = {0};

    const struct message_guid null = { GUID_NULL, {0} };
    struct message_guid guid, guid2;
    const char *tmp;

    /* null is null */
    CU_ASSERT_EQUAL(message_guid_isnull(&null), 1);

    /* set null produces null */
    message_guid_set_null(&guid);
    CU_ASSERT_EQUAL(guid.status, null.status);
    CU_ASSERT_EQUAL(memcmp(&guid.value, &null.value, sizeof(null.value)), 0);

    /* XXX is null equal to itself, or not? i.e. is it like zero, or like NaN? */
    /* treating it like zero for now */
    CU_ASSERT_EQUAL(message_guid_equal(&guid, &null), 1);
    CU_ASSERT_EQUAL(message_guid_cmp(&guid, &null), 0);
    CU_ASSERT_EQUAL(message_guid_cmp(&null, &guid), 0);

    /* if GUID_NULL status is set, (possibly-junk) bytes in value should be ignored */
    memset(&guid.value, 0x45, sizeof(guid.value));
    CU_ASSERT_EQUAL(message_guid_isnull(&guid), 1);
    CU_ASSERT_EQUAL(message_guid_equal(&guid, &null), 1);
    CU_ASSERT_EQUAL(message_guid_cmp(&guid, &null), 0);
    CU_ASSERT_EQUAL(message_guid_cmp(&null, &guid), 0);

    /* copy of null message_guid does not copy its (possibly-junk) value */
    message_guid_copy(&guid2, &guid);
    CU_ASSERT_EQUAL(guid2.status, guid.status);
    CU_ASSERT(memcmp(&guid2.value, &guid.value, sizeof(guid.value)) != 0);
    CU_ASSERT(memcmp(&guid2.value, SHA1BIN, sizeof(SHA1BIN)) == 0);

    /* set null discards old value, even if old status was already null */
    message_guid_set_null(&guid);
    CU_ASSERT_EQUAL(memcmp(&guid.value, &null.value, sizeof(null.value)), 0);

    /* encode null => NULL */
    tmp = message_guid_encode(&null);
    CU_ASSERT_PTR_NULL(tmp);

    /* decode of non-hex bytes produces null guid */
    CU_ASSERT_EQUAL(message_guid_decode(&guid, "this is not a hex string"), 0);
    CU_ASSERT_EQUAL(message_guid_isnull(&guid), 1);

    /* XXX import/export? */
}

static void test_nonnull_zero(void)
{
    static const char SHA1HEX[41] = "0000000000000000000000000000000000000000";
    static const unsigned char SHA1BIN[20] = {0};

    const struct message_guid nonnull_zero = { GUID_NONNULL, {0} };
    const struct message_guid null = { GUID_NULL, {0} };
    struct message_guid guid;
    const char *tmp;

    /* is not null, despite value being all zeroes */
    CU_ASSERT_EQUAL(message_guid_isnull(&nonnull_zero), 0);

    /* non-null zero is equal to itself */
    CU_ASSERT_EQUAL(message_guid_equal(&nonnull_zero, &nonnull_zero), 1);
    CU_ASSERT(message_guid_cmp(&nonnull_zero, &nonnull_zero) == 0);

    /* non-null zero is not equal to null */
    CU_ASSERT_EQUAL(message_guid_equal(&null, &nonnull_zero), 0);
    CU_ASSERT_EQUAL(message_guid_equal(&nonnull_zero, &null), 0);
    CU_ASSERT(message_guid_cmp(&null, &nonnull_zero) < 0);
    CU_ASSERT(message_guid_cmp(&nonnull_zero, &null) > 0);

    /* copy of non-null zero equals non-null zero */
    message_guid_copy(&guid, &nonnull_zero);
    CU_ASSERT_EQUAL(guid.status, nonnull_zero.status);
    CU_ASSERT_EQUAL(memcmp(&guid.value, SHA1BIN, sizeof(SHA1BIN)), 0);

    /* setnull differentiates between null and non-null zeroes*/
    message_guid_set_null(&guid);
    CU_ASSERT_EQUAL(guid.status, null.status);
    CU_ASSERT_EQUAL(memcmp(&guid.value, &null.value, sizeof(null.value)), 0);

    /* encode produces correct string */
    tmp = message_guid_encode(&nonnull_zero);
    CU_ASSERT_EQUAL(strcmp(tmp, SHA1HEX), 0);

    /* decode produces correct guid */
    CU_ASSERT_EQUAL(message_guid_decode(&guid, SHA1HEX), 1);
    CU_ASSERT_EQUAL(guid.status, nonnull_zero.status);
    CU_ASSERT_EQUAL(memcmp(&guid.value, SHA1BIN, sizeof(SHA1BIN)), 0);

    /* XXX import/export? */
}
/* vim: set ft=c: */
